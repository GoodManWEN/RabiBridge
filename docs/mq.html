<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>rabibridge.mq API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>rabibridge.mq</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import asyncio
import aio_pika
import random
import os
import zstandard as zstd
from aio_pika.abc import AbstractChannel, AbstractIncomingMessage
from types import FunctionType
from typing import Optional, Literal, Any, Callable, Tuple
from pydantic import validate_call

from .utils import logger, trace_exception, load_config, get_config_val, list_main_functions
from .serialisation import get_serialisation_handler
from .permissions import decrypt_pwd
from .models import ServiceSchema
from .exceptions import RemoteExecutionError

CONFIG = load_config()
RABBITMQ_HOST: Optional[str] = get_config_val(CONFIG, &#34;rabbitmq&#34;, &#34;RABBITMQ_HOST&#34;)
RABBITMQ_PORT: Optional[int] = get_config_val(CONFIG, &#34;rabbitmq&#34;, &#34;RABBITMQ_PORT&#34;)
RABBITMQ_USERNAME: Optional[str] = get_config_val(CONFIG, &#34;rabbitmq&#34;, &#34;RABBITMQ_USERNAME&#34;)
RABBITMQ_PASSWORD: Optional[str] = decrypt_pwd(get_config_val(CONFIG, &#34;rabbitmq&#34;, &#34;RABBITMQ_PASSWORD&#34;), get_config_val(CONFIG, &#34;secret&#34;, &#34;SECRET&#34;))
CID_MAX: Optional[int] = get_config_val(CONFIG, &#34;app&#34;, &#34;CID_MAX&#34;)
COMPRESS_THRESHOLD: Optional[int] = get_config_val(CONFIG, &#34;app&#34;, &#34;COMPRESS_THRESHOLD&#34;)
DEBUG_MODE: Optional[bool] = get_config_val(CONFIG, &#34;app&#34;, &#34;DEBUG_MODE&#34;)
SERIALISER: Optional[str] = get_config_val(CONFIG, &#34;app&#34;, &#34;SERIALISER&#34;)

if SERIALISER is None:
    SERIALISER = &#39;msgpack&#39;

serialisation_dumps, serialisation_loads = get_serialisation_handler(SERIALISER)


class RMQBase:
    def __init__(
        self, 
        loop: Optional[asyncio.AbstractEventLoop] = None, 
        host: Optional[str] = None, 
        port: Optional[int] = None, 
        username: Optional[str] = None, 
        password: Optional[str] = None
    ):
        if host is None:
            if RABBITMQ_HOST is None:
                raise ValueError(&#34;Invalid RabbitMQ host.&#34;)
            host = RABBITMQ_HOST
        self.host = host
        if port is None:
            if RABBITMQ_PORT is None:
                raise ValueError(&#34;Invalid RabbitMQ port.&#34;)
            port = RABBITMQ_PORT
        self.port = port
        if username is None:
            if RABBITMQ_USERNAME is None:
                raise ValueError(&#34;Invalid RabbitMQ username.&#34;)
            username = RABBITMQ_USERNAME
        self.username = username
        if password is None:
            if RABBITMQ_PASSWORD is None:
                raise ValueError(&#34;Invalid RabbitMQ password.&#34;)
            password = RABBITMQ_PASSWORD
        self.password = password
        self.loop = loop
        if loop is None:
            try:
                self.loop = asyncio.get_running_loop()
            except RuntimeError:
                self.loop = asyncio.new_event_loop()
                asyncio.set_event_loop(self.loop)
        self.connection = None
        self._cctx_enc = zstd.ZstdCompressor(level=3)
        self._ccxt_dec = zstd.ZstdDecompressor()
        self._zstd_magic_number = 0x28B52FFD
    
    def _stream_compress(self, body: Any) -&gt; bytes:
        body = serialisation_dumps(body)
        if len(body) &gt; COMPRESS_THRESHOLD:
            body = self._cctx_enc.compress(body)
        return body

    def _stream_decompress(self, msg_body: bytes) -&gt; Any:
        if int.from_bytes(msg_body[:4], &#39;big&#39;) == self._zstd_magic_number:
            try:
                return serialisation_loads(self._ccxt_dec.decompress(msg_body))
            except:
                raise ValueError(&#34;Decompression error.&#34;)
        return serialisation_loads(msg_body)
    
    async def connect(self) -&gt; &#39;RMQBase&#39;:
        raise NotImplementedError()
    
    async def close(self) -&gt; None:
        raise NotImplementedError()
    
    async def __aenter__(self):
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()

class RMQClient(RMQBase):
    &#39;&#39;&#39;
    Acting as a client-initiating requestor in a gateway service.
    &#39;&#39;&#39;

    def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None, host: Optional[str] = None, port: Optional[int] = None, username: Optional[str] = None, password: Optional[str] = None):
        &#39;&#39;&#39;
        The following parameters are used preferentially if they are specified, if they are not specified, the configuration file is searched to use, and an error is reported if they are not in the configuration file either.

        Args:
            loop: Event loop in this particular process. Defaults to `None`.
            host: RabbitMQ host. Defaults to `None`.
            port: RabbitMQ port. Defaults to `None`.
            username: RabbitMQ username. Defaults to `None`.
            password: RabbitMQ password. Defaults to `None`.
        &#39;&#39;&#39;
        super().__init__(loop, host, port, username, password)
        random.seed(int.from_bytes(os.urandom(4), &#39;big&#39;))
        self._cid_generator = self._cid_generator_func()
        self.result_futures = {} 
        
    @property
    def correlation_id(self) -&gt; str:
        &#39;&#39;&#39;
        A (periodically) self-incrementing pointer that should not normally be called directly by the user.
        &#39;&#39;&#39;
        return str(next(self._cid_generator))

    def _cid_generator_func(self):
        val = random.randint(0, CID_MAX) % CID_MAX
        while True:
            yield val
            val = (val + 1) % CID_MAX

    async def connect(self) -&gt; &#39;RMQClient&#39;:
        &#39;&#39;&#39;
        It should be connected using `connect()` before making the call and released using `close()` before closing the client. The client can be used as a context manager to ensure that the connection is closed properly after use.

        Examples:
            &gt;&gt;&gt; async with RMQClient(...) as client:
            ...     res = await client.remote_call(...)
            ...     print(res)
        &#39;&#39;&#39;
        self.connection = await aio_pika.connect(
            host=self.host,
            port=self.port,
            login=self.username,
            password=self.password,
        )
        self.channel = await self.connection.channel(on_return_raises=True)
        &#39;&#39;&#39;
        Current design is lacks of some flexibility, in that a call to an undeclared function can result in the channel broken and not continuing to be used any more. However, as this is the simplest way of returning an exception from a user call under AMQP that can be implemented at the moment. So, as a result, the current code requires developers to try out the code before deploying, which is not a huge drawback IMO.
        &#39;&#39;&#39;
        self.exchange = await self.channel.declare_exchange(
            name=&#39;rpc&#39;, 
            type=aio_pika.ExchangeType.DIRECT,
            durable=True
        )
        self.callback_queue = await self.channel.declare_queue(&#39;&#39;, exclusive=True)
        await self.callback_queue.consume(self._on_response, no_ack=True)
        return self
    
    async def _on_response(self, message: AbstractIncomingMessage) -&gt; None:
        logger.trace(f&#34;Received message: {message.body}, cid: {message.correlation_id}&#34;)
        if message.correlation_id is None:
            logger.warning(f&#34;Correlation ID is None: {repr(message)}&#34;)
            return 
        # else 
        try:
            future: asyncio.Future = self.result_futures.pop(message.correlation_id)
        except KeyError:
            # The task no longer exists on the front end
            # logger.trace(f&#34;Correlation ID not found: {message.correlation_id}&#34;)
            return
        future.set_result(message.body)

    async def remote_call(
        self, 
        func_name: str, 
        args: tuple[Any] = (), 
        kwargs: dict[Any] = {}, 
        ftype: Literal[&#39;async&#39;, &#39;sync&#39;] = &#39;async&#39;,
        *, 
        timeout: Optional[float] = None
    ) -&gt; Any:
        &#39;&#39;&#39;
        Args:
            func_name: function name to be called.
            args: arguments. Defaults to `()`.
            kwargs: keyword arguments. Defaults to `{}`.
            ftype: function type to be called remotely. e.g. defaults to &#39;async&#39;, and asynchronous call will be made on server side.
            timeout: Client timeout time, independent from queue timeout hyper-parameter. Defaults to `None`.

        Note:
            The timeout setting is recommended to be consistent with the timeout of the back-end service, if not, there may be a situation where the front-end has already timed out but the back-end still continues to execute the task.
            This is due to the loose coupling of front-end and back-end in rabbitmq, and the timeout cancellation mechanism can not be controlled by the publisher, active cancellation is not easy to realize.
            This function will uplift errors that may occur during execution:

            This function raises errors that may occur during execution, possible errors are: call queue is full (aio_pika.Basic.Nack), call timeout (asyncio.TimeoutError), remote execution error (rabibridge.RemoteExecutionError).

        Examples:
            &gt;&gt;&gt; try:
            ...     res = await client.remote_call(...)
            &gt;&gt;&gt; Except Exceition as e:
            ...     ...
            
        Returns:
            Any: (result) The result of the remote call.
        &#39;&#39;&#39;

        # res_future = self.loop.create_future() # may cause future belongs to a different loop error under some particular engine implementation. Currently don&#39;t know reason.
        res_future = asyncio.Future()
        correlation_id = self.correlation_id
        self.result_futures[correlation_id] = res_future
        body: bytes = self._stream_compress([args, kwargs])

        logger.trace(f&#34;Call async: {func_name}, {args}, {kwargs}, cid: {correlation_id}, sent body: {body}, routing_key: {ftype}_{func_name}&#34;)
        try:
            await self.exchange.publish(
                aio_pika.Message(
                    body=body,
                    correlation_id=correlation_id,
                    reply_to=self.callback_queue.name
                ),
                routing_key=f&#34;{ftype}_{func_name}&#34;,
                mandatory=True
            )
        except Exception as e: # Basic.Nack
            del self.result_futures[correlation_id]
            raise e

        try:
            res_bytes = await asyncio.wait_for(res_future, timeout=timeout)
            err_code, res = self._stream_decompress(res_bytes)
        except asyncio.TimeoutError as toe:
            logger.error(f&#34;Timeout/decode error, cid: {correlation_id}&#34;)
            del self.result_futures[correlation_id]
            raise toe
        else:
            logger.trace(f&#34;Result: {err_code}: {res}, cid: {correlation_id}&#34;)
            if err_code == 1:
                raise RemoteExecutionError(res)
            return res
        
    async def try_remote_call(
        self, 
        func_name: str, 
        args: tuple[Any] = (), 
        kwargs: dict[Any] = {}, 
        ftype: Literal[&#39;async&#39;, &#39;sync&#39;] = &#39;async&#39;,
        *, 
        timeout: Optional[float] = None
    ) -&gt; Tuple[bool, Tuple[int, Any]]:
        &#39;&#39;&#39;
        A simplified way of writing remote_call, there is no essential difference between the two. Instead of doing a try except externally, you control the process execution through the error code.

        Return:
            (bool, Tuple[int, Any]): (success, (err_code, result))
            Where success means if the call successfully returns on client side, if it returns normally, it means that no timeout or full queue error has occurred, but this does not mean that the returned result is reliable.
            While err_code means if the call run smoothly on remote side, 0 for success, 1 for error. 

            The relationship between success and err_code: If error_code is 0, the result is reliable. If error_code is 1, it is necessary to determine whether the error occurred on the client or server side based on success.
        &#39;&#39;&#39;
        try:
            res: Tuple[int, Any] = await self.remote_call(func_name, args, kwargs, ftype, timeout=timeout)
            return True, res
        except Exception as e:
            return False, [1, e]


    async def close(self):
        if self.connection is not None:
            await self.connection.close()


class RMQServer(RMQBase):
    &#39;&#39;&#39;
    Used to provide services with daemon process.
    &#39;&#39;&#39;

    def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None, host: Optional[str] = None, port: Optional[int] = None, username: Optional[str] = None, password: Optional[str] = None):
        &#39;&#39;&#39;
        The following parameters are used preferentially if they are specified, if they are not specified, the configuration file is searched to use, and an error is reported if they are not in the configuration file either.

        Args:
            loop: Event loop in this particular process. Defaults to `None`.
            host: RabbitMQ host. Defaults to `None`.
            port: RabbitMQ port. Defaults to `None`.
            username: RabbitMQ username. Defaults to `None`.
            password: RabbitMQ password. Defaults to `None`.
        &#39;&#39;&#39;
        super().__init__(loop, host, port, username, password)
        self.services: Optional[dict[str, ServiceSchema]] = None
        self.channels: list[AbstractChannel] = []
        self._srv_coros = []

    @validate_call
    def load_services(self, symbols: dict[str, object]) -&gt; None:
        &#39;&#39;&#39;
        Automatically captures all registered functions in global space, using which requires that all the specified call has already been registered.

        Args:
            symbols: global dict.

        Examples:
            &gt;&gt;&gt; @register_call(...)
            &gt;&gt;&gt; def call_1():
            ...     ...
            &gt;&gt;&gt; obj.load_services(globals())
            None # call_1 has been loaded
        &#39;&#39;&#39;
        self.services = {}
        for name, ptr in list_main_functions(symbols, banned_names=[]):
            schema = getattr(ptr, &#39;_schema&#39;, None)
            if schema is None: 
                continue
                # queue_size, fetch_size, timeout, re_register, is_async = None, None, None, False, asyncio.iscoroutinefunction(ptr)
            else:
                queue_size, fetch_size, timeout, re_register, is_async = schema.values()
            if queue_size is not None and fetch_size is not None:
                assert fetch_size &lt;= queue_size # have to be true
            queue_name = f&#34;rpc_{&#39;async&#39; if is_async else &#39;sync&#39;}_{name}&#34;
            self.services[queue_name] = {
                &#39;queue_name&#39;: queue_name, 
                &#39;queue_obj&#39;: None,
                &#39;func_ptr&#39;: ptr, 
                &#39;queue_size&#39;: queue_size, 
                &#39;fetch_size&#39;: fetch_size,
                &#39;timeout&#39;: timeout,
                &#39;re_register&#39;: re_register,
                &#39;is_async&#39;: is_async
            }
            logger.info(f&#34;Service {queue_name} loaded. queue_size: {queue_size}, fetch_size: {fetch_size}. {ptr}&#34;)

    @validate_call
    def add_service(self, func_ptr: Callable[..., Any], queue_size: Optional[int], fetch_size: Optional[int], timeout: Optional[int] = None, re_register: bool = False):
        &#39;&#39;&#39;
        If you do not wish to use automatic capture, you can register the service manually. Manually registered services do not need to be pre-registered using the `recister_call` decorator.

        For technical details and meanings of the parameters, please refer to the description in `register_call`.

        Args:
            func_ptr: function pointer.
            queue_size: queue size.
            fetch_size: fetch size.
            timeout: timeout. Defaults to `None`.
            re_register: re-register. Defaults to `False`.
            
        &#39;&#39;&#39;
        if not isinstance(func_ptr, FunctionType):
            raise ValueError(&#34;func_ptr must be a function pointer.&#34;)
        label = &#39;sync&#39;
        if asyncio.iscoroutinefunction(func_ptr):
            label = &#39;async&#39;
        queue_name = f&#34;rpc_{label}_{func_ptr.__name__}&#34;
        if queue_size is not None and fetch_size is not None:
            assert fetch_size &lt;= queue_size # have to be true
        if self.services is None:
            self.services = {}
        self.services[queue_name] = {
            &#39;queue_name&#39;: queue_name, 
            &#39;queue_obj&#39;: None,
            &#39;func_ptr&#39;: func_ptr, 
            &#39;queue_size&#39;: queue_size, 
            &#39;fetch_size&#39;: fetch_size,
            &#39;timeout&#39;: timeout,
            &#39;re_register&#39;: re_register
        }
        logger.info(f&#34;Service {queue_name} loaded. queue_size: {queue_size}, fetch_size: {fetch_size}. {func_ptr}&#34;)

    async def connect(self) -&gt; &#34;RMQServer&#34;:
        &#39;&#39;&#39;
        It should be connected using `connect()` before making the call and released using `close()` before closing the client. The client can be used as a context manager to ensure that the connection is closed properly after use.
        
        Examples:
            &gt;&gt;&gt; s = RMQServer(...)
            &gt;&gt;&gt; s.load_services(globals())
            &gt;&gt;&gt; async with s:
            ...     await server.run_serve()
        &#39;&#39;&#39;
        if self.services is None:
            raise ValueError(&#34;Services not loaded, you must load services first.&#34;)
        if self.connection is not None:
            raise ValueError(&#34;Connection already exists.&#34;)
        
        self.connection = await aio_pika.connect(
            host=self.host,
            port=self.port,
            login=self.username,
            password=self.password
        )

        for queue_name, serv_obj in self.services.items():
            queue_name, _, func_ptr, queue_size, fetch_size, timeout, re_register, is_async = serv_obj.values()
            # channel
            channel: AbstractChannel = await self.connection.channel()
            if fetch_size is not None:
                await channel.set_qos(prefetch_count=fetch_size)
            self.channels.append(channel)
            exchange = await channel.declare_exchange(
                name=&#39;rpc&#39;,
                type=aio_pika.ExchangeType.DIRECT,
                durable=True
            )

            # queue
            args = {&#39;x-overflow&#39;: &#39;reject-publish&#39;}
            if timeout is not None:
                args[&#39;x-message-ttl&#39;] = timeout
            if queue_size is not None:
                args[&#39;x-max-length&#39;] = queue_size
            if re_register:
                try:
                    await channel.declare_queue(name=queue_name, durable=True, arguments=args, passive=True)
                    await channel.queue_delete(queue_name)
                    logger.trace(f&#34;Queue {queue_name} exist, former one deleted.&#34;)
                except aio_pika.exceptions.ChannelClosed:
                    # queue does not exist
                    logger.trace(f&#34;Queue {queue_name} does not exist.&#34;)
            queue = await channel.declare_queue(name=queue_name, durable=True, arguments=args)
            await queue.bind(exchange, routing_key=queue_name[4:])
            self.services[queue_name][&#39;queue_obj&#39;] = queue 
            self._srv_coros.append(self._queue_listen_handler(queue, func_ptr, channel, is_async_function=is_async))
            
        return self
    

    async def _call_handler(self, message: AbstractIncomingMessage, func_ptr: callable, channel: AbstractChannel, is_async_function: bool):
        try:
            async with message.process():
                if message.reply_to is None:
                    raise ValueError(&#34;Reply_to queue is None&#34;)
                args, kwargs = self._stream_decompress(message.body)
                logger.debug(f&#34;Received message: {args}, {kwargs}, cid: {message.correlation_id}, reply_to: {message.reply_to}&#34;)
                call_code: int = 0 
                try:
                    if is_async_function:
                        result = await func_ptr(*args, **kwargs)
                    else:
                        result = func_ptr(*args, **kwargs)       ### TBD: migration to use thread pooling for execution
                except Exception as e:
                    call_code = 1
                    trace_exception(e)
                if call_code == 0:
                    logger.trace(f&#34;Run result: {result}&#34;)
                    ret_body = self._stream_compress([call_code, result])
                else:
                    err_msg = trace_exception(e)
                    logger.debug(f&#34;Run error: {err_msg}&#34;)
                    ret_body = self._stream_compress([call_code, err_msg])
                await channel.default_exchange.publish(
                    aio_pika.Message(
                        body=ret_body, 
                        correlation_id=message.correlation_id
                    ),
                    routing_key=message.reply_to
                )
                logger.trace(f&#34;Sent result: {result}, cid: {message.correlation_id}&#34;)
        except Exception as e:
            if DEBUG_MODE:
                raise e
            logger.error(trace_exception(e))

    async def _queue_listen_handler(self, queue: aio_pika.Queue, func_ptr: callable, channel: AbstractChannel, is_async_function: bool):
        logger.info(&#39;start listening&#39;)  
        async with queue.iterator() as qiterator:
            async for message in qiterator: # message: AbstractIncomingMessage
                self.loop.create_task(self._call_handler(message, func_ptr, channel, is_async_function))

    async def run_serve(self):
        &#39;&#39;&#39;
        Start the service, the program will block once called.
        &#39;&#39;&#39;
        logger.info(&#39;start serving...&#39;)
        await asyncio.gather(*self._srv_coros)
  
    async def close(self):
        logger.info(&#39;closing...&#39;)
        if self.connection is not None:
            await self.connection.close()

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="rabibridge.mq.RMQBase"><code class="flex name class">
<span>class <span class="ident">RMQBase</span></span>
<span>(</span><span>loop: Optional[asyncio.events.AbstractEventLoop] = None, host: Optional[str] = None, port: Optional[int] = None, username: Optional[str] = None, password: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RMQBase:
    def __init__(
        self, 
        loop: Optional[asyncio.AbstractEventLoop] = None, 
        host: Optional[str] = None, 
        port: Optional[int] = None, 
        username: Optional[str] = None, 
        password: Optional[str] = None
    ):
        if host is None:
            if RABBITMQ_HOST is None:
                raise ValueError(&#34;Invalid RabbitMQ host.&#34;)
            host = RABBITMQ_HOST
        self.host = host
        if port is None:
            if RABBITMQ_PORT is None:
                raise ValueError(&#34;Invalid RabbitMQ port.&#34;)
            port = RABBITMQ_PORT
        self.port = port
        if username is None:
            if RABBITMQ_USERNAME is None:
                raise ValueError(&#34;Invalid RabbitMQ username.&#34;)
            username = RABBITMQ_USERNAME
        self.username = username
        if password is None:
            if RABBITMQ_PASSWORD is None:
                raise ValueError(&#34;Invalid RabbitMQ password.&#34;)
            password = RABBITMQ_PASSWORD
        self.password = password
        self.loop = loop
        if loop is None:
            try:
                self.loop = asyncio.get_running_loop()
            except RuntimeError:
                self.loop = asyncio.new_event_loop()
                asyncio.set_event_loop(self.loop)
        self.connection = None
        self._cctx_enc = zstd.ZstdCompressor(level=3)
        self._ccxt_dec = zstd.ZstdDecompressor()
        self._zstd_magic_number = 0x28B52FFD
    
    def _stream_compress(self, body: Any) -&gt; bytes:
        body = serialisation_dumps(body)
        if len(body) &gt; COMPRESS_THRESHOLD:
            body = self._cctx_enc.compress(body)
        return body

    def _stream_decompress(self, msg_body: bytes) -&gt; Any:
        if int.from_bytes(msg_body[:4], &#39;big&#39;) == self._zstd_magic_number:
            try:
                return serialisation_loads(self._ccxt_dec.decompress(msg_body))
            except:
                raise ValueError(&#34;Decompression error.&#34;)
        return serialisation_loads(msg_body)
    
    async def connect(self) -&gt; &#39;RMQBase&#39;:
        raise NotImplementedError()
    
    async def close(self) -&gt; None:
        raise NotImplementedError()
    
    async def __aenter__(self):
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="rabibridge.mq.RMQClient" href="#rabibridge.mq.RMQClient">RMQClient</a></li>
<li><a title="rabibridge.mq.RMQServer" href="#rabibridge.mq.RMQServer">RMQServer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="rabibridge.mq.RMQBase.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="rabibridge.mq.RMQBase.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self) ‑> <a title="rabibridge.mq.RMQBase" href="#rabibridge.mq.RMQBase">RMQBase</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self) -&gt; &#39;RMQBase&#39;:
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="rabibridge.mq.RMQClient"><code class="flex name class">
<span>class <span class="ident">RMQClient</span></span>
<span>(</span><span>loop: Optional[asyncio.events.AbstractEventLoop] = None, host: Optional[str] = None, port: Optional[int] = None, username: Optional[str] = None, password: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Acting as a client-initiating requestor in a gateway service.</p>
<p>The following parameters are used preferentially if they are specified, if they are not specified, the configuration file is searched to use, and an error is reported if they are not in the configuration file either.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>loop</code></strong></dt>
<dd>Event loop in this particular process. Defaults to <code>None</code>.</dd>
<dt><strong><code>host</code></strong></dt>
<dd>RabbitMQ host. Defaults to <code>None</code>.</dd>
<dt><strong><code>port</code></strong></dt>
<dd>RabbitMQ port. Defaults to <code>None</code>.</dd>
<dt><strong><code>username</code></strong></dt>
<dd>RabbitMQ username. Defaults to <code>None</code>.</dd>
<dt><strong><code>password</code></strong></dt>
<dd>RabbitMQ password. Defaults to <code>None</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RMQClient(RMQBase):
    &#39;&#39;&#39;
    Acting as a client-initiating requestor in a gateway service.
    &#39;&#39;&#39;

    def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None, host: Optional[str] = None, port: Optional[int] = None, username: Optional[str] = None, password: Optional[str] = None):
        &#39;&#39;&#39;
        The following parameters are used preferentially if they are specified, if they are not specified, the configuration file is searched to use, and an error is reported if they are not in the configuration file either.

        Args:
            loop: Event loop in this particular process. Defaults to `None`.
            host: RabbitMQ host. Defaults to `None`.
            port: RabbitMQ port. Defaults to `None`.
            username: RabbitMQ username. Defaults to `None`.
            password: RabbitMQ password. Defaults to `None`.
        &#39;&#39;&#39;
        super().__init__(loop, host, port, username, password)
        random.seed(int.from_bytes(os.urandom(4), &#39;big&#39;))
        self._cid_generator = self._cid_generator_func()
        self.result_futures = {} 
        
    @property
    def correlation_id(self) -&gt; str:
        &#39;&#39;&#39;
        A (periodically) self-incrementing pointer that should not normally be called directly by the user.
        &#39;&#39;&#39;
        return str(next(self._cid_generator))

    def _cid_generator_func(self):
        val = random.randint(0, CID_MAX) % CID_MAX
        while True:
            yield val
            val = (val + 1) % CID_MAX

    async def connect(self) -&gt; &#39;RMQClient&#39;:
        &#39;&#39;&#39;
        It should be connected using `connect()` before making the call and released using `close()` before closing the client. The client can be used as a context manager to ensure that the connection is closed properly after use.

        Examples:
            &gt;&gt;&gt; async with RMQClient(...) as client:
            ...     res = await client.remote_call(...)
            ...     print(res)
        &#39;&#39;&#39;
        self.connection = await aio_pika.connect(
            host=self.host,
            port=self.port,
            login=self.username,
            password=self.password,
        )
        self.channel = await self.connection.channel(on_return_raises=True)
        &#39;&#39;&#39;
        Current design is lacks of some flexibility, in that a call to an undeclared function can result in the channel broken and not continuing to be used any more. However, as this is the simplest way of returning an exception from a user call under AMQP that can be implemented at the moment. So, as a result, the current code requires developers to try out the code before deploying, which is not a huge drawback IMO.
        &#39;&#39;&#39;
        self.exchange = await self.channel.declare_exchange(
            name=&#39;rpc&#39;, 
            type=aio_pika.ExchangeType.DIRECT,
            durable=True
        )
        self.callback_queue = await self.channel.declare_queue(&#39;&#39;, exclusive=True)
        await self.callback_queue.consume(self._on_response, no_ack=True)
        return self
    
    async def _on_response(self, message: AbstractIncomingMessage) -&gt; None:
        logger.trace(f&#34;Received message: {message.body}, cid: {message.correlation_id}&#34;)
        if message.correlation_id is None:
            logger.warning(f&#34;Correlation ID is None: {repr(message)}&#34;)
            return 
        # else 
        try:
            future: asyncio.Future = self.result_futures.pop(message.correlation_id)
        except KeyError:
            # The task no longer exists on the front end
            # logger.trace(f&#34;Correlation ID not found: {message.correlation_id}&#34;)
            return
        future.set_result(message.body)

    async def remote_call(
        self, 
        func_name: str, 
        args: tuple[Any] = (), 
        kwargs: dict[Any] = {}, 
        ftype: Literal[&#39;async&#39;, &#39;sync&#39;] = &#39;async&#39;,
        *, 
        timeout: Optional[float] = None
    ) -&gt; Any:
        &#39;&#39;&#39;
        Args:
            func_name: function name to be called.
            args: arguments. Defaults to `()`.
            kwargs: keyword arguments. Defaults to `{}`.
            ftype: function type to be called remotely. e.g. defaults to &#39;async&#39;, and asynchronous call will be made on server side.
            timeout: Client timeout time, independent from queue timeout hyper-parameter. Defaults to `None`.

        Note:
            The timeout setting is recommended to be consistent with the timeout of the back-end service, if not, there may be a situation where the front-end has already timed out but the back-end still continues to execute the task.
            This is due to the loose coupling of front-end and back-end in rabbitmq, and the timeout cancellation mechanism can not be controlled by the publisher, active cancellation is not easy to realize.
            This function will uplift errors that may occur during execution:

            This function raises errors that may occur during execution, possible errors are: call queue is full (aio_pika.Basic.Nack), call timeout (asyncio.TimeoutError), remote execution error (rabibridge.RemoteExecutionError).

        Examples:
            &gt;&gt;&gt; try:
            ...     res = await client.remote_call(...)
            &gt;&gt;&gt; Except Exceition as e:
            ...     ...
            
        Returns:
            Any: (result) The result of the remote call.
        &#39;&#39;&#39;

        # res_future = self.loop.create_future() # may cause future belongs to a different loop error under some particular engine implementation. Currently don&#39;t know reason.
        res_future = asyncio.Future()
        correlation_id = self.correlation_id
        self.result_futures[correlation_id] = res_future
        body: bytes = self._stream_compress([args, kwargs])

        logger.trace(f&#34;Call async: {func_name}, {args}, {kwargs}, cid: {correlation_id}, sent body: {body}, routing_key: {ftype}_{func_name}&#34;)
        try:
            await self.exchange.publish(
                aio_pika.Message(
                    body=body,
                    correlation_id=correlation_id,
                    reply_to=self.callback_queue.name
                ),
                routing_key=f&#34;{ftype}_{func_name}&#34;,
                mandatory=True
            )
        except Exception as e: # Basic.Nack
            del self.result_futures[correlation_id]
            raise e

        try:
            res_bytes = await asyncio.wait_for(res_future, timeout=timeout)
            err_code, res = self._stream_decompress(res_bytes)
        except asyncio.TimeoutError as toe:
            logger.error(f&#34;Timeout/decode error, cid: {correlation_id}&#34;)
            del self.result_futures[correlation_id]
            raise toe
        else:
            logger.trace(f&#34;Result: {err_code}: {res}, cid: {correlation_id}&#34;)
            if err_code == 1:
                raise RemoteExecutionError(res)
            return res
        
    async def try_remote_call(
        self, 
        func_name: str, 
        args: tuple[Any] = (), 
        kwargs: dict[Any] = {}, 
        ftype: Literal[&#39;async&#39;, &#39;sync&#39;] = &#39;async&#39;,
        *, 
        timeout: Optional[float] = None
    ) -&gt; Tuple[bool, Tuple[int, Any]]:
        &#39;&#39;&#39;
        A simplified way of writing remote_call, there is no essential difference between the two. Instead of doing a try except externally, you control the process execution through the error code.

        Return:
            (bool, Tuple[int, Any]): (success, (err_code, result))
            Where success means if the call successfully returns on client side, if it returns normally, it means that no timeout or full queue error has occurred, but this does not mean that the returned result is reliable.
            While err_code means if the call run smoothly on remote side, 0 for success, 1 for error. 

            The relationship between success and err_code: If error_code is 0, the result is reliable. If error_code is 1, it is necessary to determine whether the error occurred on the client or server side based on success.
        &#39;&#39;&#39;
        try:
            res: Tuple[int, Any] = await self.remote_call(func_name, args, kwargs, ftype, timeout=timeout)
            return True, res
        except Exception as e:
            return False, [1, e]


    async def close(self):
        if self.connection is not None:
            await self.connection.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="rabibridge.mq.RMQBase" href="#rabibridge.mq.RMQBase">RMQBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="rabibridge.mq.RMQClient.correlation_id"><code class="name">var <span class="ident">correlation_id</span> : str</code></dt>
<dd>
<div class="desc"><p>A (periodically) self-incrementing pointer that should not normally be called directly by the user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def correlation_id(self) -&gt; str:
    &#39;&#39;&#39;
    A (periodically) self-incrementing pointer that should not normally be called directly by the user.
    &#39;&#39;&#39;
    return str(next(self._cid_generator))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="rabibridge.mq.RMQClient.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self):
    if self.connection is not None:
        await self.connection.close()</code></pre>
</details>
</dd>
<dt id="rabibridge.mq.RMQClient.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self) ‑> <a title="rabibridge.mq.RMQClient" href="#rabibridge.mq.RMQClient">RMQClient</a></span>
</code></dt>
<dd>
<div class="desc"><p>It should be connected using <code>connect()</code> before making the call and released using <code>close()</code> before closing the client. The client can be used as a context manager to ensure that the connection is closed properly after use.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; async with RMQClient(...) as client:
...     res = await client.remote_call(...)
...     print(res)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self) -&gt; &#39;RMQClient&#39;:
    &#39;&#39;&#39;
    It should be connected using `connect()` before making the call and released using `close()` before closing the client. The client can be used as a context manager to ensure that the connection is closed properly after use.

    Examples:
        &gt;&gt;&gt; async with RMQClient(...) as client:
        ...     res = await client.remote_call(...)
        ...     print(res)
    &#39;&#39;&#39;
    self.connection = await aio_pika.connect(
        host=self.host,
        port=self.port,
        login=self.username,
        password=self.password,
    )
    self.channel = await self.connection.channel(on_return_raises=True)
    &#39;&#39;&#39;
    Current design is lacks of some flexibility, in that a call to an undeclared function can result in the channel broken and not continuing to be used any more. However, as this is the simplest way of returning an exception from a user call under AMQP that can be implemented at the moment. So, as a result, the current code requires developers to try out the code before deploying, which is not a huge drawback IMO.
    &#39;&#39;&#39;
    self.exchange = await self.channel.declare_exchange(
        name=&#39;rpc&#39;, 
        type=aio_pika.ExchangeType.DIRECT,
        durable=True
    )
    self.callback_queue = await self.channel.declare_queue(&#39;&#39;, exclusive=True)
    await self.callback_queue.consume(self._on_response, no_ack=True)
    return self</code></pre>
</details>
</dd>
<dt id="rabibridge.mq.RMQClient.remote_call"><code class="name flex">
<span>async def <span class="ident">remote_call</span></span>(<span>self, func_name: str, args: tuple[typing.Any] = (), kwargs: dict[typing.Any] = {}, ftype: Literal['async', 'sync'] = 'async', *, timeout: Optional[float] = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>func_name</code></strong></dt>
<dd>function name to be called.</dd>
<dt><strong><code>args</code></strong></dt>
<dd>arguments. Defaults to <code>()</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>keyword arguments. Defaults to <code>{}</code>.</dd>
<dt><strong><code>ftype</code></strong></dt>
<dd>function type to be called remotely. e.g. defaults to 'async', and asynchronous call will be made on server side.</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>Client timeout time, independent from queue timeout hyper-parameter. Defaults to <code>None</code>.</dd>
</dl>
<h2 id="note">Note</h2>
<p>The timeout setting is recommended to be consistent with the timeout of the back-end service, if not, there may be a situation where the front-end has already timed out but the back-end still continues to execute the task.
This is due to the loose coupling of front-end and back-end in rabbitmq, and the timeout cancellation mechanism can not be controlled by the publisher, active cancellation is not easy to realize.
This function will uplift errors that may occur during execution:</p>
<p>This function raises errors that may occur during execution, possible errors are: call queue is full (aio_pika.Basic.Nack), call timeout (asyncio.TimeoutError), remote execution error (rabibridge.RemoteExecutionError).</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; try:
...     res = await client.remote_call(...)
&gt;&gt;&gt; Except Exceition as e:
...     ...
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>(result) The result of the remote call.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def remote_call(
    self, 
    func_name: str, 
    args: tuple[Any] = (), 
    kwargs: dict[Any] = {}, 
    ftype: Literal[&#39;async&#39;, &#39;sync&#39;] = &#39;async&#39;,
    *, 
    timeout: Optional[float] = None
) -&gt; Any:
    &#39;&#39;&#39;
    Args:
        func_name: function name to be called.
        args: arguments. Defaults to `()`.
        kwargs: keyword arguments. Defaults to `{}`.
        ftype: function type to be called remotely. e.g. defaults to &#39;async&#39;, and asynchronous call will be made on server side.
        timeout: Client timeout time, independent from queue timeout hyper-parameter. Defaults to `None`.

    Note:
        The timeout setting is recommended to be consistent with the timeout of the back-end service, if not, there may be a situation where the front-end has already timed out but the back-end still continues to execute the task.
        This is due to the loose coupling of front-end and back-end in rabbitmq, and the timeout cancellation mechanism can not be controlled by the publisher, active cancellation is not easy to realize.
        This function will uplift errors that may occur during execution:

        This function raises errors that may occur during execution, possible errors are: call queue is full (aio_pika.Basic.Nack), call timeout (asyncio.TimeoutError), remote execution error (rabibridge.RemoteExecutionError).

    Examples:
        &gt;&gt;&gt; try:
        ...     res = await client.remote_call(...)
        &gt;&gt;&gt; Except Exceition as e:
        ...     ...
        
    Returns:
        Any: (result) The result of the remote call.
    &#39;&#39;&#39;

    # res_future = self.loop.create_future() # may cause future belongs to a different loop error under some particular engine implementation. Currently don&#39;t know reason.
    res_future = asyncio.Future()
    correlation_id = self.correlation_id
    self.result_futures[correlation_id] = res_future
    body: bytes = self._stream_compress([args, kwargs])

    logger.trace(f&#34;Call async: {func_name}, {args}, {kwargs}, cid: {correlation_id}, sent body: {body}, routing_key: {ftype}_{func_name}&#34;)
    try:
        await self.exchange.publish(
            aio_pika.Message(
                body=body,
                correlation_id=correlation_id,
                reply_to=self.callback_queue.name
            ),
            routing_key=f&#34;{ftype}_{func_name}&#34;,
            mandatory=True
        )
    except Exception as e: # Basic.Nack
        del self.result_futures[correlation_id]
        raise e

    try:
        res_bytes = await asyncio.wait_for(res_future, timeout=timeout)
        err_code, res = self._stream_decompress(res_bytes)
    except asyncio.TimeoutError as toe:
        logger.error(f&#34;Timeout/decode error, cid: {correlation_id}&#34;)
        del self.result_futures[correlation_id]
        raise toe
    else:
        logger.trace(f&#34;Result: {err_code}: {res}, cid: {correlation_id}&#34;)
        if err_code == 1:
            raise RemoteExecutionError(res)
        return res</code></pre>
</details>
</dd>
<dt id="rabibridge.mq.RMQClient.try_remote_call"><code class="name flex">
<span>async def <span class="ident">try_remote_call</span></span>(<span>self, func_name: str, args: tuple[typing.Any] = (), kwargs: dict[typing.Any] = {}, ftype: Literal['async', 'sync'] = 'async', *, timeout: Optional[float] = None) ‑> Tuple[bool, Tuple[int, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>A simplified way of writing remote_call, there is no essential difference between the two. Instead of doing a try except externally, you control the process execution through the error code.</p>
<h2 id="return">Return</h2>
<p>(bool, Tuple[int, Any]): (success, (err_code, result))
Where success means if the call successfully returns on client side, if it returns normally, it means that no timeout or full queue error has occurred, but this does not mean that the returned result is reliable.
While err_code means if the call run smoothly on remote side, 0 for success, 1 for error. </p>
<p>The relationship between success and err_code: If error_code is 0, the result is reliable. If error_code is 1, it is necessary to determine whether the error occurred on the client or server side based on success.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def try_remote_call(
    self, 
    func_name: str, 
    args: tuple[Any] = (), 
    kwargs: dict[Any] = {}, 
    ftype: Literal[&#39;async&#39;, &#39;sync&#39;] = &#39;async&#39;,
    *, 
    timeout: Optional[float] = None
) -&gt; Tuple[bool, Tuple[int, Any]]:
    &#39;&#39;&#39;
    A simplified way of writing remote_call, there is no essential difference between the two. Instead of doing a try except externally, you control the process execution through the error code.

    Return:
        (bool, Tuple[int, Any]): (success, (err_code, result))
        Where success means if the call successfully returns on client side, if it returns normally, it means that no timeout or full queue error has occurred, but this does not mean that the returned result is reliable.
        While err_code means if the call run smoothly on remote side, 0 for success, 1 for error. 

        The relationship between success and err_code: If error_code is 0, the result is reliable. If error_code is 1, it is necessary to determine whether the error occurred on the client or server side based on success.
    &#39;&#39;&#39;
    try:
        res: Tuple[int, Any] = await self.remote_call(func_name, args, kwargs, ftype, timeout=timeout)
        return True, res
    except Exception as e:
        return False, [1, e]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="rabibridge.mq.RMQServer"><code class="flex name class">
<span>class <span class="ident">RMQServer</span></span>
<span>(</span><span>loop: Optional[asyncio.events.AbstractEventLoop] = None, host: Optional[str] = None, port: Optional[int] = None, username: Optional[str] = None, password: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to provide services with daemon process.</p>
<p>The following parameters are used preferentially if they are specified, if they are not specified, the configuration file is searched to use, and an error is reported if they are not in the configuration file either.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>loop</code></strong></dt>
<dd>Event loop in this particular process. Defaults to <code>None</code>.</dd>
<dt><strong><code>host</code></strong></dt>
<dd>RabbitMQ host. Defaults to <code>None</code>.</dd>
<dt><strong><code>port</code></strong></dt>
<dd>RabbitMQ port. Defaults to <code>None</code>.</dd>
<dt><strong><code>username</code></strong></dt>
<dd>RabbitMQ username. Defaults to <code>None</code>.</dd>
<dt><strong><code>password</code></strong></dt>
<dd>RabbitMQ password. Defaults to <code>None</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RMQServer(RMQBase):
    &#39;&#39;&#39;
    Used to provide services with daemon process.
    &#39;&#39;&#39;

    def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None, host: Optional[str] = None, port: Optional[int] = None, username: Optional[str] = None, password: Optional[str] = None):
        &#39;&#39;&#39;
        The following parameters are used preferentially if they are specified, if they are not specified, the configuration file is searched to use, and an error is reported if they are not in the configuration file either.

        Args:
            loop: Event loop in this particular process. Defaults to `None`.
            host: RabbitMQ host. Defaults to `None`.
            port: RabbitMQ port. Defaults to `None`.
            username: RabbitMQ username. Defaults to `None`.
            password: RabbitMQ password. Defaults to `None`.
        &#39;&#39;&#39;
        super().__init__(loop, host, port, username, password)
        self.services: Optional[dict[str, ServiceSchema]] = None
        self.channels: list[AbstractChannel] = []
        self._srv_coros = []

    @validate_call
    def load_services(self, symbols: dict[str, object]) -&gt; None:
        &#39;&#39;&#39;
        Automatically captures all registered functions in global space, using which requires that all the specified call has already been registered.

        Args:
            symbols: global dict.

        Examples:
            &gt;&gt;&gt; @register_call(...)
            &gt;&gt;&gt; def call_1():
            ...     ...
            &gt;&gt;&gt; obj.load_services(globals())
            None # call_1 has been loaded
        &#39;&#39;&#39;
        self.services = {}
        for name, ptr in list_main_functions(symbols, banned_names=[]):
            schema = getattr(ptr, &#39;_schema&#39;, None)
            if schema is None: 
                continue
                # queue_size, fetch_size, timeout, re_register, is_async = None, None, None, False, asyncio.iscoroutinefunction(ptr)
            else:
                queue_size, fetch_size, timeout, re_register, is_async = schema.values()
            if queue_size is not None and fetch_size is not None:
                assert fetch_size &lt;= queue_size # have to be true
            queue_name = f&#34;rpc_{&#39;async&#39; if is_async else &#39;sync&#39;}_{name}&#34;
            self.services[queue_name] = {
                &#39;queue_name&#39;: queue_name, 
                &#39;queue_obj&#39;: None,
                &#39;func_ptr&#39;: ptr, 
                &#39;queue_size&#39;: queue_size, 
                &#39;fetch_size&#39;: fetch_size,
                &#39;timeout&#39;: timeout,
                &#39;re_register&#39;: re_register,
                &#39;is_async&#39;: is_async
            }
            logger.info(f&#34;Service {queue_name} loaded. queue_size: {queue_size}, fetch_size: {fetch_size}. {ptr}&#34;)

    @validate_call
    def add_service(self, func_ptr: Callable[..., Any], queue_size: Optional[int], fetch_size: Optional[int], timeout: Optional[int] = None, re_register: bool = False):
        &#39;&#39;&#39;
        If you do not wish to use automatic capture, you can register the service manually. Manually registered services do not need to be pre-registered using the `recister_call` decorator.

        For technical details and meanings of the parameters, please refer to the description in `register_call`.

        Args:
            func_ptr: function pointer.
            queue_size: queue size.
            fetch_size: fetch size.
            timeout: timeout. Defaults to `None`.
            re_register: re-register. Defaults to `False`.
            
        &#39;&#39;&#39;
        if not isinstance(func_ptr, FunctionType):
            raise ValueError(&#34;func_ptr must be a function pointer.&#34;)
        label = &#39;sync&#39;
        if asyncio.iscoroutinefunction(func_ptr):
            label = &#39;async&#39;
        queue_name = f&#34;rpc_{label}_{func_ptr.__name__}&#34;
        if queue_size is not None and fetch_size is not None:
            assert fetch_size &lt;= queue_size # have to be true
        if self.services is None:
            self.services = {}
        self.services[queue_name] = {
            &#39;queue_name&#39;: queue_name, 
            &#39;queue_obj&#39;: None,
            &#39;func_ptr&#39;: func_ptr, 
            &#39;queue_size&#39;: queue_size, 
            &#39;fetch_size&#39;: fetch_size,
            &#39;timeout&#39;: timeout,
            &#39;re_register&#39;: re_register
        }
        logger.info(f&#34;Service {queue_name} loaded. queue_size: {queue_size}, fetch_size: {fetch_size}. {func_ptr}&#34;)

    async def connect(self) -&gt; &#34;RMQServer&#34;:
        &#39;&#39;&#39;
        It should be connected using `connect()` before making the call and released using `close()` before closing the client. The client can be used as a context manager to ensure that the connection is closed properly after use.
        
        Examples:
            &gt;&gt;&gt; s = RMQServer(...)
            &gt;&gt;&gt; s.load_services(globals())
            &gt;&gt;&gt; async with s:
            ...     await server.run_serve()
        &#39;&#39;&#39;
        if self.services is None:
            raise ValueError(&#34;Services not loaded, you must load services first.&#34;)
        if self.connection is not None:
            raise ValueError(&#34;Connection already exists.&#34;)
        
        self.connection = await aio_pika.connect(
            host=self.host,
            port=self.port,
            login=self.username,
            password=self.password
        )

        for queue_name, serv_obj in self.services.items():
            queue_name, _, func_ptr, queue_size, fetch_size, timeout, re_register, is_async = serv_obj.values()
            # channel
            channel: AbstractChannel = await self.connection.channel()
            if fetch_size is not None:
                await channel.set_qos(prefetch_count=fetch_size)
            self.channels.append(channel)
            exchange = await channel.declare_exchange(
                name=&#39;rpc&#39;,
                type=aio_pika.ExchangeType.DIRECT,
                durable=True
            )

            # queue
            args = {&#39;x-overflow&#39;: &#39;reject-publish&#39;}
            if timeout is not None:
                args[&#39;x-message-ttl&#39;] = timeout
            if queue_size is not None:
                args[&#39;x-max-length&#39;] = queue_size
            if re_register:
                try:
                    await channel.declare_queue(name=queue_name, durable=True, arguments=args, passive=True)
                    await channel.queue_delete(queue_name)
                    logger.trace(f&#34;Queue {queue_name} exist, former one deleted.&#34;)
                except aio_pika.exceptions.ChannelClosed:
                    # queue does not exist
                    logger.trace(f&#34;Queue {queue_name} does not exist.&#34;)
            queue = await channel.declare_queue(name=queue_name, durable=True, arguments=args)
            await queue.bind(exchange, routing_key=queue_name[4:])
            self.services[queue_name][&#39;queue_obj&#39;] = queue 
            self._srv_coros.append(self._queue_listen_handler(queue, func_ptr, channel, is_async_function=is_async))
            
        return self
    

    async def _call_handler(self, message: AbstractIncomingMessage, func_ptr: callable, channel: AbstractChannel, is_async_function: bool):
        try:
            async with message.process():
                if message.reply_to is None:
                    raise ValueError(&#34;Reply_to queue is None&#34;)
                args, kwargs = self._stream_decompress(message.body)
                logger.debug(f&#34;Received message: {args}, {kwargs}, cid: {message.correlation_id}, reply_to: {message.reply_to}&#34;)
                call_code: int = 0 
                try:
                    if is_async_function:
                        result = await func_ptr(*args, **kwargs)
                    else:
                        result = func_ptr(*args, **kwargs)       ### TBD: migration to use thread pooling for execution
                except Exception as e:
                    call_code = 1
                    trace_exception(e)
                if call_code == 0:
                    logger.trace(f&#34;Run result: {result}&#34;)
                    ret_body = self._stream_compress([call_code, result])
                else:
                    err_msg = trace_exception(e)
                    logger.debug(f&#34;Run error: {err_msg}&#34;)
                    ret_body = self._stream_compress([call_code, err_msg])
                await channel.default_exchange.publish(
                    aio_pika.Message(
                        body=ret_body, 
                        correlation_id=message.correlation_id
                    ),
                    routing_key=message.reply_to
                )
                logger.trace(f&#34;Sent result: {result}, cid: {message.correlation_id}&#34;)
        except Exception as e:
            if DEBUG_MODE:
                raise e
            logger.error(trace_exception(e))

    async def _queue_listen_handler(self, queue: aio_pika.Queue, func_ptr: callable, channel: AbstractChannel, is_async_function: bool):
        logger.info(&#39;start listening&#39;)  
        async with queue.iterator() as qiterator:
            async for message in qiterator: # message: AbstractIncomingMessage
                self.loop.create_task(self._call_handler(message, func_ptr, channel, is_async_function))

    async def run_serve(self):
        &#39;&#39;&#39;
        Start the service, the program will block once called.
        &#39;&#39;&#39;
        logger.info(&#39;start serving...&#39;)
        await asyncio.gather(*self._srv_coros)
  
    async def close(self):
        logger.info(&#39;closing...&#39;)
        if self.connection is not None:
            await self.connection.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="rabibridge.mq.RMQBase" href="#rabibridge.mq.RMQBase">RMQBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="rabibridge.mq.RMQServer.add_service"><code class="name flex">
<span>def <span class="ident">add_service</span></span>(<span>self, func_ptr: Callable[..., Any], queue_size: Optional[int], fetch_size: Optional[int], timeout: Optional[int] = None, re_register: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>If you do not wish to use automatic capture, you can register the service manually. Manually registered services do not need to be pre-registered using the <code>recister_call</code> decorator.</p>
<p>For technical details and meanings of the parameters, please refer to the description in <code>register_call</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func_ptr</code></strong></dt>
<dd>function pointer.</dd>
<dt><strong><code>queue_size</code></strong></dt>
<dd>queue size.</dd>
<dt><strong><code>fetch_size</code></strong></dt>
<dd>fetch size.</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>timeout. Defaults to <code>None</code>.</dd>
<dt><strong><code>re_register</code></strong></dt>
<dd>re-register. Defaults to <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def add_service(self, func_ptr: Callable[..., Any], queue_size: Optional[int], fetch_size: Optional[int], timeout: Optional[int] = None, re_register: bool = False):
    &#39;&#39;&#39;
    If you do not wish to use automatic capture, you can register the service manually. Manually registered services do not need to be pre-registered using the `recister_call` decorator.

    For technical details and meanings of the parameters, please refer to the description in `register_call`.

    Args:
        func_ptr: function pointer.
        queue_size: queue size.
        fetch_size: fetch size.
        timeout: timeout. Defaults to `None`.
        re_register: re-register. Defaults to `False`.
        
    &#39;&#39;&#39;
    if not isinstance(func_ptr, FunctionType):
        raise ValueError(&#34;func_ptr must be a function pointer.&#34;)
    label = &#39;sync&#39;
    if asyncio.iscoroutinefunction(func_ptr):
        label = &#39;async&#39;
    queue_name = f&#34;rpc_{label}_{func_ptr.__name__}&#34;
    if queue_size is not None and fetch_size is not None:
        assert fetch_size &lt;= queue_size # have to be true
    if self.services is None:
        self.services = {}
    self.services[queue_name] = {
        &#39;queue_name&#39;: queue_name, 
        &#39;queue_obj&#39;: None,
        &#39;func_ptr&#39;: func_ptr, 
        &#39;queue_size&#39;: queue_size, 
        &#39;fetch_size&#39;: fetch_size,
        &#39;timeout&#39;: timeout,
        &#39;re_register&#39;: re_register
    }
    logger.info(f&#34;Service {queue_name} loaded. queue_size: {queue_size}, fetch_size: {fetch_size}. {func_ptr}&#34;)</code></pre>
</details>
</dd>
<dt id="rabibridge.mq.RMQServer.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self):
    logger.info(&#39;closing...&#39;)
    if self.connection is not None:
        await self.connection.close()</code></pre>
</details>
</dd>
<dt id="rabibridge.mq.RMQServer.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self) ‑> <a title="rabibridge.mq.RMQServer" href="#rabibridge.mq.RMQServer">RMQServer</a></span>
</code></dt>
<dd>
<div class="desc"><p>It should be connected using <code>connect()</code> before making the call and released using <code>close()</code> before closing the client. The client can be used as a context manager to ensure that the connection is closed properly after use.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; s = RMQServer(...)
&gt;&gt;&gt; s.load_services(globals())
&gt;&gt;&gt; async with s:
...     await server.run_serve()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self) -&gt; &#34;RMQServer&#34;:
    &#39;&#39;&#39;
    It should be connected using `connect()` before making the call and released using `close()` before closing the client. The client can be used as a context manager to ensure that the connection is closed properly after use.
    
    Examples:
        &gt;&gt;&gt; s = RMQServer(...)
        &gt;&gt;&gt; s.load_services(globals())
        &gt;&gt;&gt; async with s:
        ...     await server.run_serve()
    &#39;&#39;&#39;
    if self.services is None:
        raise ValueError(&#34;Services not loaded, you must load services first.&#34;)
    if self.connection is not None:
        raise ValueError(&#34;Connection already exists.&#34;)
    
    self.connection = await aio_pika.connect(
        host=self.host,
        port=self.port,
        login=self.username,
        password=self.password
    )

    for queue_name, serv_obj in self.services.items():
        queue_name, _, func_ptr, queue_size, fetch_size, timeout, re_register, is_async = serv_obj.values()
        # channel
        channel: AbstractChannel = await self.connection.channel()
        if fetch_size is not None:
            await channel.set_qos(prefetch_count=fetch_size)
        self.channels.append(channel)
        exchange = await channel.declare_exchange(
            name=&#39;rpc&#39;,
            type=aio_pika.ExchangeType.DIRECT,
            durable=True
        )

        # queue
        args = {&#39;x-overflow&#39;: &#39;reject-publish&#39;}
        if timeout is not None:
            args[&#39;x-message-ttl&#39;] = timeout
        if queue_size is not None:
            args[&#39;x-max-length&#39;] = queue_size
        if re_register:
            try:
                await channel.declare_queue(name=queue_name, durable=True, arguments=args, passive=True)
                await channel.queue_delete(queue_name)
                logger.trace(f&#34;Queue {queue_name} exist, former one deleted.&#34;)
            except aio_pika.exceptions.ChannelClosed:
                # queue does not exist
                logger.trace(f&#34;Queue {queue_name} does not exist.&#34;)
        queue = await channel.declare_queue(name=queue_name, durable=True, arguments=args)
        await queue.bind(exchange, routing_key=queue_name[4:])
        self.services[queue_name][&#39;queue_obj&#39;] = queue 
        self._srv_coros.append(self._queue_listen_handler(queue, func_ptr, channel, is_async_function=is_async))
        
    return self</code></pre>
</details>
</dd>
<dt id="rabibridge.mq.RMQServer.load_services"><code class="name flex">
<span>def <span class="ident">load_services</span></span>(<span>self, symbols: dict[str, object]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Automatically captures all registered functions in global space, using which requires that all the specified call has already been registered.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>symbols</code></strong></dt>
<dd>global dict.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; @register_call(...)
&gt;&gt;&gt; def call_1():
...     ...
&gt;&gt;&gt; obj.load_services(globals())
None # call_1 has been loaded
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def load_services(self, symbols: dict[str, object]) -&gt; None:
    &#39;&#39;&#39;
    Automatically captures all registered functions in global space, using which requires that all the specified call has already been registered.

    Args:
        symbols: global dict.

    Examples:
        &gt;&gt;&gt; @register_call(...)
        &gt;&gt;&gt; def call_1():
        ...     ...
        &gt;&gt;&gt; obj.load_services(globals())
        None # call_1 has been loaded
    &#39;&#39;&#39;
    self.services = {}
    for name, ptr in list_main_functions(symbols, banned_names=[]):
        schema = getattr(ptr, &#39;_schema&#39;, None)
        if schema is None: 
            continue
            # queue_size, fetch_size, timeout, re_register, is_async = None, None, None, False, asyncio.iscoroutinefunction(ptr)
        else:
            queue_size, fetch_size, timeout, re_register, is_async = schema.values()
        if queue_size is not None and fetch_size is not None:
            assert fetch_size &lt;= queue_size # have to be true
        queue_name = f&#34;rpc_{&#39;async&#39; if is_async else &#39;sync&#39;}_{name}&#34;
        self.services[queue_name] = {
            &#39;queue_name&#39;: queue_name, 
            &#39;queue_obj&#39;: None,
            &#39;func_ptr&#39;: ptr, 
            &#39;queue_size&#39;: queue_size, 
            &#39;fetch_size&#39;: fetch_size,
            &#39;timeout&#39;: timeout,
            &#39;re_register&#39;: re_register,
            &#39;is_async&#39;: is_async
        }
        logger.info(f&#34;Service {queue_name} loaded. queue_size: {queue_size}, fetch_size: {fetch_size}. {ptr}&#34;)</code></pre>
</details>
</dd>
<dt id="rabibridge.mq.RMQServer.run_serve"><code class="name flex">
<span>async def <span class="ident">run_serve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the service, the program will block once called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def run_serve(self):
    &#39;&#39;&#39;
    Start the service, the program will block once called.
    &#39;&#39;&#39;
    logger.info(&#39;start serving...&#39;)
    await asyncio.gather(*self._srv_coros)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="rabibridge" href="index.html">rabibridge</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="rabibridge.mq.RMQBase" href="#rabibridge.mq.RMQBase">RMQBase</a></code></h4>
<ul class="">
<li><code><a title="rabibridge.mq.RMQBase.close" href="#rabibridge.mq.RMQBase.close">close</a></code></li>
<li><code><a title="rabibridge.mq.RMQBase.connect" href="#rabibridge.mq.RMQBase.connect">connect</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rabibridge.mq.RMQClient" href="#rabibridge.mq.RMQClient">RMQClient</a></code></h4>
<ul class="">
<li><code><a title="rabibridge.mq.RMQClient.close" href="#rabibridge.mq.RMQClient.close">close</a></code></li>
<li><code><a title="rabibridge.mq.RMQClient.connect" href="#rabibridge.mq.RMQClient.connect">connect</a></code></li>
<li><code><a title="rabibridge.mq.RMQClient.correlation_id" href="#rabibridge.mq.RMQClient.correlation_id">correlation_id</a></code></li>
<li><code><a title="rabibridge.mq.RMQClient.remote_call" href="#rabibridge.mq.RMQClient.remote_call">remote_call</a></code></li>
<li><code><a title="rabibridge.mq.RMQClient.try_remote_call" href="#rabibridge.mq.RMQClient.try_remote_call">try_remote_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rabibridge.mq.RMQServer" href="#rabibridge.mq.RMQServer">RMQServer</a></code></h4>
<ul class="">
<li><code><a title="rabibridge.mq.RMQServer.add_service" href="#rabibridge.mq.RMQServer.add_service">add_service</a></code></li>
<li><code><a title="rabibridge.mq.RMQServer.close" href="#rabibridge.mq.RMQServer.close">close</a></code></li>
<li><code><a title="rabibridge.mq.RMQServer.connect" href="#rabibridge.mq.RMQServer.connect">connect</a></code></li>
<li><code><a title="rabibridge.mq.RMQServer.load_services" href="#rabibridge.mq.RMQServer.load_services">load_services</a></code></li>
<li><code><a title="rabibridge.mq.RMQServer.run_serve" href="#rabibridge.mq.RMQServer.run_serve">run_serve</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>